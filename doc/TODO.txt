Deadlines
reuniao presencial (prox ou semana que vem que vem)

* supondo defesa dia 15/12:
	* entrega da monografia: 8/12
	* ter toda implementação pronta: 17/11
> Na prática, a defesa poderá ser feita até fevereiro do ano que vem

A defesa de TCC pode ser adiantada (so que a nota so vai sair em março)


Focus
* (OK) Execute functions
* (OK) Execute recursion
* (OK) Space/Skip directives
> write tests

* Handle exit syscall in debugger by returning the Exited StopReason event
> This will likely require adding a return type to the 'handle' method of the debugger
* Prepare a test to sort a vector (bubble sort)
* Prepare a test to multiply elements of a vector (bubble sort)
* Prepare a gdb tutorial (generating code through my program+ debugging it through gdb)
* Improve code tracing during debug/runtime (r/w of registers/memory)
* Replace comment start from // to # in order to behave as 'as'
* Set starting code address
> use _start as the starting label

* Improve debugger (maybe with dwarf info through gimli or addr2line)
> This is harder than it looks. This would require inferring
> functions/variables and more by either analysing the IR of the code or by
> annotating those things explicitly through macros such as the ones
> supported by gnu/gcc (.define .function, .endfunction, ...).
>> Maybe that's too much considering the gains (a richer gdb debugging session)
>>> Enriching debug sessions isn't required in order to run code. Generating
>>> debug info isn't mandatory aswell for that matter.

* Create tests to check memory alignment after Parser runs

* Improve commandline interface
* Remove warnings when compiling
* Create pseudo instructions for push/pop/managing stack on func entry/exit?
* Write tests for:
	* Memory trait
	* CPU trait
	* DataEndianness
	* Machine methods
	* Final Symbol Address
	* Instruction immediate and instruction format
* Create more methods for 'AssemblerTools' (retrieve symbol final address, find address of line, ...)
* machine::handle isn't using the methods of the Machine trait for r/w memory/cpu...

* Create Loader entity
* Create Executor entity
	* assembly into &[u32]
	* debugger
	* elf parser


Code
* Assess the use of u32, i32, usize, ... throughout the project
	* Watch out for places in the code using 'as' casts
* Write simple field evaluator to handle constant expressions?
* Rewrite parts of the code where 'eprintln' is (poorly) used or isn't adequate
* Write logger
* pub(crate), pub(self), pub(in path) instead of raw pub
* fix bug where consecutive bytes arent side by side in the memory of the machine
> side by side byte instructions (`.byte 0x1 \n .byte 0x2`) don't get merged
> into the same word, but in different words. That's fine for now. If this
> behavior has to change later on, then these functions will have to be
> editted: assembler::generic_to_encodable_lines,
> assembler::gen_section_address, assembler::gen_line_address,
> assembler::gen_symbol_table. The address generation process will be subject
> to change, because fixing this bug would affect the address of the two
> consecutive bytes in code



Design/Improvements
* Use &str instead of String for the Tokenizer
* Review lexer/tokenizer names
	* Lexer isnt really a lexer, more like a categorizer/classifier/parser
* Review how args (for instructions) are being handled
	* This is a vector of 0-3 elements
	* The instruction requires a syntax and args, which are then parsed by the function 'get_args'
* Review using 'Rc' in order to reduce the number of duplicates for instances of 'dyn Extension'



Test
* Add second extension
	* Check how hard it is to add a new extension



Docs
* Document how parsing '1(r1)' is different than '1(varname)'
	* 1(r1) = Offset + Reg
	* 1(varname) = Name(addr, addend)
* Document known issues
	* `.byte 0x1 \n .byte 0x2`, 
	* Things like 'la t1, 100(var1)' are now possible, but there's currently no
	  check for if 100 % 4 == 0 (for example). This could mess with the text
	  section alignment 
* Document how relocation works
* Document how addresses get generated




Misc
* [X] The strategy used to create software breaks isnt ideal for the debugger...
* [X] Prepare tests to test out all instructions from the RV32I (running in memory)
* [X] Support arrays (addresses + offset)
* [X] do not override symbol/string/relocation table when the symbol appears
  multiple times in the code
> For each symbol reference,a new relocation gets created
* [X] support minimal instruction set
	* add
	* and
	* or (R)
	* lui (U)
	* jal (J)
	* addi
	* andi
	* ori
	* lw (I)
	* sw (S)
	* beq
	* blt (B)
* [X] Parse riscv32 elf files, decode instructions and execute them in a Virtual Context
* [X] Fix the binary encoding of some instruction formats
* [X] Create spec::ImmediateFormat
* [X] Support running real code in a virtual machine
